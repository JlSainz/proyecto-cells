/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
import { LitElement } from 'lit-element';
import { dedupingMixin } from '@cells-components/cells-lit-helpers/utils/mixin.js';

// Contains all connected resizables that do not have a parent.
window.ORPHANS = window.ORPHANS || new Set();

/**
 * `CellsResizableMixin` is a mixin that can be used in components to
 * coordinate the flow of resize events between "resizers" (elements that control the
 * size or hidden state of their children) and "resizables" (elements that need to be
 * notified when they are resized or un-hidden by their parents in order to take
 * action on their new measurements).
 *
 * Elements that perform measurement should add the `CellsResizableMixin` mixin to
 * their element definition and listen for the `cells-resize` event on themselves.
 * This event will be fired when they become showing after having been hidden,
 * when they are resized explicitly by another resizable, or when the window has been
 * resized.
 *
 * Note, the `cells-resize` event is non-bubbling.
 *
 * @mixinFunction
 * @demo demo/index.html
 **/
export const CellsResizableMixin = dedupingMixin(superClass => {
  return class extends superClass {
    static get properties() {
      return {
        /**
         * The closest ancestor element that implements `CellsResizableMixin`.
         */
        _parentResizable: {
          type: Object,
          observer: '_parentResizableChanged',
        },

        /**
         * True if this element is currently notifying its descendant elements of
         * resize.
         */
        _notifyingDescendant: {
          type: Boolean,
          value: false,
        }
      };
    }

    constructor() {
      super();

      // We don't really need property effects on these, and also we want them
      // to be created before the `_parentResizable` observer fires:
      this._interestedResizables = [];
      this._boundNotifyResize = this.notifyResize.bind(this);
      this._boundOnDescendantCellsResize = this._onDescendantCellsResize.bind(this);
      this.addEventListener('cells-request-resize-notifications', this._onCellsRequestResizeNotifications);
    }

    connectedCallback() {
      super.connectedCallback();
      this.isAttached = true;
      this._requestResizeNotifications();
    }

    disconnectedCallback() {
      super.disconnectedCallback();
      this.isAttached = false;
      if (this._parentResizable) {
        this._parentResizable.stopResizeNotificationsFor(this);
      } else {
        window.ORPHANS.delete(this);
        window.removeEventListener('resize', this._boundNotifyResize);
      }

      this._parentResizable = null;
    }

    /**
     * Can be called to manually notify a resizable and its descendant
     * resizables of a resize change.
     */
    notifyResize() {
      if (!this.isAttached) {
        return;
      }

      this._interestedResizables.forEach((resizable) => {
        if (this.resizerShouldNotify(resizable)) {
          this._notifyDescendant(resizable);
        }
      }, this);

      this._fireResize();
    }

    /**
     * Used to assign the closest resizable ancestor to this resizable
     * if the ancestor detects a request for notifications.
     */
    assignParentResizable(parentResizable) {
      if (this._parentResizable) {
        this._parentResizable.stopResizeNotificationsFor(this);
      }

      this._parentResizable = parentResizable;

      if (parentResizable && parentResizable._interestedResizables.indexOf(this) === -1) {
        parentResizable._interestedResizables.push(this);
        parentResizable._subscribeCellsResize(this);
      }
    }

    /**
     * Used to remove a resizable descendant from the list of descendants
     * that should be notified of a resize change.
     */
    stopResizeNotificationsFor(target) {
      var index = this._interestedResizables.indexOf(target);

      if (index > -1) {
        this._interestedResizables.splice(index, 1);
        this._unsubscribeCellsResize(target);
      }
    }

    /**
     * Subscribe this element to listen to cells-resize events on the given target.
     *
     * Preferred over target.listen because the property renamer does not
     * understand to rename when the target is not specifically "this"
     *
     * @param {!HTMLElement} target Element to listen to for cells-resize events.
     */
    _subscribeCellsResize(target) {
      target.addEventListener('cells-resize', this._boundOnDescendantCellsResize);
    }

    /**
     * Unsubscribe this element from listening to to cells-resize events on the
     * given target.
     *
     * Preferred over target.unlisten because the property renamer does not
     * understand to rename when the target is not specifically "this"
     *
     * @param {!HTMLElement} target Element to listen to for cells-resize events.
     */
    _unsubscribeCellsResize(target) {
      target.removeEventListener('cells-resize', this._boundOnDescendantCellsResize);
    }

    /**
     * This method can be overridden to filter nested elements that should or
     * should not be notified by the current element. Return true if an element
     * should be notified, or false if it should not be notified.
     *
     * @param {HTMLElement} element A candidate descendant element that
     * implements `CellsResizableMixin`.
     * @return {boolean} True if the `element` should be notified of resize.
     */
    resizerShouldNotify(element) {
      return true;
    }

    _onDescendantCellsResize(event) {
      if (this._notifyingDescendant) {
        event.stopPropagation();
        return;
      }

      // no need to use this during shadow dom because of event retargeting
      const useShadow = !(window.ShadyDOM);
      if (!useShadow) {
        this._fireResize();
      }
    }

    _fireResize() {
      this.dispatchEvent(new CustomEvent('cells-resize', {
        bubbles: false,
        composed: true,
        node: this
      }));
    }

    _onCellsRequestResizeNotifications(event) {
      var target = /** @type {!EventTarget} */ (event.composedPath()[0]);
      if (target === this) {
        return;
      }

      target.assignParentResizable(this);
      this._notifyDescendant(target);

      event.stopPropagation();
    }

    _parentResizableChanged(parentResizable) {
      if (parentResizable) {
        window.removeEventListener('resize', this._boundNotifyResize);
      }
    }

    _notifyDescendant(descendant) {
      // NOTE(cdata): In IE10, attached is fired on children first, so it's
      // important not to notify them if the parent is not attached yet (or
      // else they will get redundantly notified when the parent attaches).
      if (!this.isAttached) {
        return;
      }

      this._notifyingDescendant = true;
      descendant.notifyResize();
      this._notifyingDescendant = false;
    }

    _requestResizeNotifications() {
      if (!this.isAttached) {
        return;
      }

      if (document.readyState === 'loading') {
        var _requestResizeNotifications = this._requestResizeNotifications.bind(this);
        document.addEventListener('readystatechange', function readystatechanged() {
          document.removeEventListener('readystatechange', readystatechanged);
          _requestResizeNotifications();
        });
      } else {
        this._findParent();

        if (!this._parentResizable) {
          // If this resizable is an orphan, tell other orphans to try to find
          // their parent again, in case it's this resizable.
          window.ORPHANS.forEach(function(orphan) {
            if (orphan !== this) {
              orphan._findParent();
            }
          }, this);

          window.addEventListener('resize', this._boundNotifyResize);
          this.notifyResize();
        } else {
          // If this resizable has a parent, tell other child resizables of
          // that parent to try finding their parent again, in case it's this
          // resizable.
          this._parentResizable._interestedResizables.forEach(function(resizable) {
            if (resizable !== this) {
              resizable._findParent();
            }
          }, this);
        }
      }
    }

    _findParent() {
      this.assignParentResizable(null);
      this.dispatchEvent(new CustomEvent('cells-request-resize-notifications', {
        bubbles: true,
        composed: true,
        cancelable: true,
        node: this
      }));
      if (!this._parentResizable) {
        window.ORPHANS.add(this);
      } else {
        window.ORPHANS.delete(this);
      }
    }
  };
});
