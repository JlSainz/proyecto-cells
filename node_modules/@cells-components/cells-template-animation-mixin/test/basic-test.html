<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">

  <script src="../node_modules/@webcomponents/webcomponentsjs/webcomponents-loader.js"></script>
  <script src="../node_modules/mocha/mocha.js"></script>
  <script src="../node_modules/wct-mocha/wct-mocha.js"></script>
  <script src="../node_modules/chai/chai.js"></script>
  <script src="../node_modules/sinon/pkg/sinon.js"></script>
  <script src="../node_modules/@polymer/test-fixture/test-fixture.js"></script>
  <script src="../node_modules/sinon-chai/lib/sinon-chai.js"></script>
</head>

<body>

  <test-fixture id="myEl">
    <template>
      <cells-template-paper-drawer-panel id="tplOne" name="tplOne"></cells-template-paper-drawer-panel>
      <cells-template-paper-drawer-panel id="tplTwo" name="tplTwo" state="inactive"></cells-template-paper-drawer-panel>
    </template>
  </test-fixture>

  <script type="module">
    import './test.js';
    suite('cells-template-animation-mixin', () => {
      let el;
      let tplOne;
      let otherTpl;
      let navigate;

      setup(async () => {
        el = fixture('myEl');
        tplOne = el[0];
        otherTpl = el[1];
        navigate = (tplFrom, tplTo) => {
          tplFrom.state = 'inactive';
          tplTo.state = 'active';
        };
        await tplOne.updateComplete;
        await otherTpl.updateComplete;
      });

      suite('State', () => {
        test('setting state to active animates the inactive sibling template', async () => {
          let siblingTplIsAnimating = otherTpl.classList.contains('template-animation-is-animating');
          tplOne.state = 'active';
          await tplOne.updateComplete;
          assert.notEqual(otherTpl.classList.contains('template-animation-is-animating'), siblingTplIsAnimating);
          assert.isTrue(otherTpl.classList.contains('template-animation-is-animating'));
        });

        test('setting state to active adds "state-is-visible" class if there is no inactive sibling template', (done) => {
          let initialClass = otherTpl.classList.contains('state-is-visible');
          otherTpl.state = 'active';

          requestAnimationFrame(() => {
            assert.notEqual(otherTpl.classList.contains('state-is-visible'), initialClass);
            assert.isTrue(otherTpl.classList.contains('state-is-visible'));
            done();
          });
        });
      });

      suite('Animation types', () => {
        suite('animationType to "horizontal"', () => {
          setup(() => {
            navigate(tplOne, otherTpl);
          });

          test('outgoing and incoming templates moves to left in forwards direction', (done) => {
            otherTpl.addEventListener('animation-forward', () => {
              assert.isTrue(tplOne.classList.contains('template-animation-moveFromRight'));
              assert.isTrue(otherTpl.classList.contains('template-animation-moveToLeft'));
              done();
            });

            navigate(otherTpl, tplOne);
          });

          // test('outgoing and incoming templates moves to right in backwards direction', (done) => {
          //   tplOne.addEventListener('animation-backward', () => {
          //     assert.isTrue(otherTpl.classList.contains('template-animation-moveFromLeft'));
          //     assert.isTrue(tplOne.classList.contains('template-animation-moveToRight'));
          //     done();
          //   });
          //   navigate(otherTpl, tplOne);
          // });
        });

        suite('animationType to "verticalDownForwards"', () => {
          setup(async () => {
            tplOne.animationType = 'verticalDownForwards';
            otherTpl.animationType = 'horizontal';
            await tplOne.updateComplete;
            await otherTpl.updateComplete;
            navigate(tplOne, otherTpl);
          });

          test('outgoing template moves to bottom in forwards direction', (done) => {
            tplOne.addEventListener('animation-forward', () => {
              assert.isTrue(otherTpl.classList.contains('template-animation-static'));
              assert.isTrue(tplOne.classList.contains('template-animation-moveToBottom'));
              done();
            });

            navigate(otherTpl, tplOne);
          });

          test('outgoing and incoming templates moves to right in backwards direction', (done) => {
            otherTpl.addEventListener('animation-backward', () => {
              assert.isTrue(tplOne.classList.contains('template-animation-moveFromLeft'));
              assert.isTrue(otherTpl.classList.contains('template-animation-moveToRight'));
              done();
            });

            navigate(otherTpl, tplOne);
          });
        });


        suite('animationType to "verticalUpForwards"', () => {
          setup(async () => {
            tplOne.animationType = 'verticalUpForwards';
            otherTpl.animationType = 'horizontal';
            await tplOne.updateComplete;
            await otherTpl.updateComplete;
            navigate(tplOne, otherTpl);
          });

          test('outgoing template moves to top in forwards direction', (done) => {
            tplOne.addEventListener('animation-forward', () => {
              assert.isTrue(otherTpl.classList.contains('template-animation-moveFromBottom'));
              assert.isTrue(tplOne.classList.contains('template-animation-static'));
              done();
            });

            navigate(otherTpl, tplOne);
          });

          test('outgoing and incoming templates moves to right in backwards direction', (done) => {
            otherTpl.addEventListener('animation-backward', () => {
              assert.isTrue(tplOne.classList.contains('template-animation-moveFromLeft'));
              assert.isTrue(otherTpl.classList.contains('template-animation-moveToRight'));
              done();
            });

            navigate(otherTpl, tplOne);
          });
        });

        suite('animationType to "verticalDownBackwards"', () => {
          setup(async () => {
            tplOne.animationType = 'horizontal';
            otherTpl.animationType = 'verticalDownBackwards';
            await tplOne.updateComplete;
            await otherTpl.updateComplete;
            navigate(tplOne, otherTpl);
          });

          test('outgoing and incoming templates moves to left in forwards direction', (done) => {
            tplOne.addEventListener('animation-forward', () => {
              assert.isTrue(otherTpl.classList.contains('template-animation-moveFromRight'));
              assert.isTrue(tplOne.classList.contains('template-animation-moveToLeft'));
              done();
            });

            navigate(otherTpl, tplOne);
          });

          test('outgoing template moves to bottom in backwards direction', (done) => {
            otherTpl.addEventListener('animation-backward', () => {
              assert.isTrue(tplOne.classList.contains('template-animation-static'));
              assert.isTrue(otherTpl.classList.contains('template-animation-moveToBottom'));
              done();
            });

            navigate(otherTpl, tplOne);
          });
        });

        suite('animationType to "verticalUp"', () => {
          setup(async () => {
            tplOne.animationType = 'static';
            otherTpl.animationType = 'verticalUp';
            await tplOne.updateComplete;
            await otherTpl.updateComplete;
            navigate(tplOne, otherTpl);
          });

          test('incoming template moves from bottom to top while outgoing remains static in forwards direction', (done) => {
            tplOne.addEventListener('animation-forward', () => {
              assert.isTrue(otherTpl.classList.contains('template-animation-moveFromBottom'));
              assert.isTrue(tplOne.classList.contains('template-animation-static'));
              done();
            });

            navigate(otherTpl, tplOne);
          });

          test('outgoing template moves to bottom while incoming template remains static in backwards direction', (done) => {
            otherTpl.addEventListener('animation-backward', () => {
              assert.isTrue(tplOne.classList.contains('template-animation-static'));
              assert.isTrue(otherTpl.classList.contains('template-animation-moveToBottom'));
              done();
            });

            navigate(otherTpl, tplOne);
          });
        });

        suite('animationType to "staticEver"', () => {
          setup(async () => {
            tplOne.animationType = 'staticEver';
            otherTpl.animationType = 'staticEver';
            await tplOne.updateComplete;
            await otherTpl.updateComplete;
            navigate(tplOne, otherTpl);
          });

          test('both templates remains static (no animation) in forwards direction', (done) => {
            tplOne.addEventListener('animation-forward', () => {
              assert.isTrue(tplOne.classList.contains('template-animation-static'));
              assert.isTrue(otherTpl.classList.contains('template-animation-static'));
              done();
            });

            navigate(otherTpl, tplOne);
          });

          test('both templates remains static (no animation) in backwards direction', (done) => {
            otherTpl.addEventListener('animation-backward', () => {
              assert.isTrue(tplOne.classList.contains('template-animation-static'));
              assert.isTrue(otherTpl.classList.contains('template-animation-static'));
              done();
            });

            navigate(otherTpl, tplOne);
          });
        });

        suite('animationType to "horizontalEver"', () => {
          setup(async () => {
            tplOne.animationType = 'static';
            otherTpl.animationType = 'horizontalEver';
            await tplOne.updateComplete;
            await otherTpl.updateComplete;
            navigate(tplOne, otherTpl);
          });

          test('both templates move to left in forwards direction', (done) => {
            tplOne.addEventListener('animation-forward', () => {
              assert.isTrue(otherTpl.classList.contains('template-animation-moveFromRight'));
              assert.isTrue(tplOne.classList.contains('template-animation-moveToLeft'));
              done();
            });

            navigate(otherTpl, tplOne);
          });

          test('outgoing and incoming templates moves to right in backwards direction', (done) => {
            otherTpl.addEventListener('animation-backward', () => {
              assert.isTrue(tplOne.classList.contains('template-animation-moveFromLeft'));
              assert.isTrue(otherTpl.classList.contains('template-animation-moveToRight'));
              done();
            });

            navigate(otherTpl, tplOne);
          });
        });

        suite('animationType to "fade"', () => {
          setup(async () => {
            tplOne.animationType = 'fade';
            otherTpl.animationType = 'fade';
            await tplOne.updateComplete;
            await otherTpl.updateComplete;
            navigate(tplOne, otherTpl);
          });

          test('both templates animation with fade', (done) => {
            tplOne.addEventListener('animation-forward', () => {
              assert.isTrue(otherTpl.classList.contains('template-animation-fade-in'));
              assert.isTrue(tplOne.classList.contains('template-animation-fade-out'));
              done();
            });

            navigate(otherTpl, tplOne);
          });

          test('both templates animation with fade', (done) => {
            otherTpl.addEventListener('animation-backward', () => {
              assert.isTrue(tplOne.classList.contains('template-animation-fade-out'));
              assert.isTrue(otherTpl.classList.contains('template-animation-fade-in'));
              done();
            });

            navigate(otherTpl, tplOne);
          });
        });

        suite('default animation', () => {
          setup(() => {
            navigate(tplOne, otherTpl);
          });

          test('animation is horizontal if the animationType of both templates does not match any known value', (done) => {
            tplOne.animationType = 'any';
            tplOne.updateComplete.then(() => {
              otherTpl.animationType = 'any';
              otherTpl.updateComplete.then(() => {
                tplOne.addEventListener('animation-forward', () => {
                  assert.isTrue(otherTpl.classList.contains('template-animation-moveFromRight'));
                  assert.isTrue(tplOne.classList.contains('template-animation-moveToLeft'));
                  done();
                });

                navigate(otherTpl, tplOne);
              });
            });
          });

          test('animation is horizontal if the animationType of the outgoing template does not match any known value', (done) => {
            tplOne.animationType = 'any';
            tplOne.updateComplete.then(() => {
              tplOne.addEventListener('animation-forward', () => {
                assert.isTrue(otherTpl.classList.contains('template-animation-moveFromRight'));
                assert.isTrue(tplOne.classList.contains('template-animation-moveToLeft'));
                done();
              });

              navigate(otherTpl, tplOne);
            });
          });

          test('animation is horizontal if the animationType of the incoming template does not match any known value', (done) => {
            otherTpl.animationType = 'any';
            otherTpl.updateComplete.then(() => {
              tplOne.addEventListener('animation-forward', () => {
                assert.isTrue(otherTpl.classList.contains('template-animation-moveFromRight'));
                assert.isTrue(tplOne.classList.contains('template-animation-moveToLeft'));
                done();
              });

              navigate(otherTpl, tplOne);
            });
          });
        });
      });
    });
  </script>
</body>

</html>
