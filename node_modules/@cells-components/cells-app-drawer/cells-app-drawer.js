/* eslint-disable new-cap */
import { LitElement, html, } from 'lit-element';
import { getComponentSharedStyles, } from '@cells-components/cells-lit-helpers/cells-lit-helpers.js';
import '@cells-components/cells-media-query/cells-media-query.js';
import '@cells-components/cells-selector/cells-selector.js';
import {classMap} from 'lit-html/directives/class-map.js';
import { CellsResizableMixin } from '@cells-components/cells-resizable-mixin/cells-resizable-mixin.js';
import * as Gestures from '@cells-components/cells-lit-helpers/utils/gestures.js';
import styles from './cells-app-drawer-styles.js';

let sharedPanel = null;

/**
`<cells-app-drawer>` contains a drawer panel and a main panel.  The drawer
and the main panel are side-by-side with drawer on the left.  When the browser
window size is smaller than the `responsiveWidth`, `cells-app-drawer`
changes to narrow layout.  In narrow layout, the drawer will be stacked on top
of the main panel.  The drawer will slide in/out to hide/reveal the main
panel.

Use the attribute `drawer` to indicate that the element is the drawer panel and
`main` to indicate that the element is the main panel.

Example:
```html
<cells-app-drawer>
  <div slot="drawer"> Drawer panel... </div>
  <div slot="main"> Main panel... </div>
</cells-app-drawer>
```

The drawer and the main panels are not scrollable.  You can set CSS overflow
property on the elements to make them scrollable or use `paper-header-panel`.

Example:
```html
<cells-app-drawer>
  <paper-header-panel slot="drawer">
    <paper-toolbar></paper-toolbar>
    <div> Drawer content... </div>
  </paper-header-panel>
  <paper-header-panel slot="main">
    <paper-toolbar></paper-toolbar>
    <div> Main content... </div>
  </paper-header-panel>
</cells-app-drawer>
```

An element that should toggle the drawer will automatically do so if it's
given the `paper-drawer-toggle` attribute.  Also this element will automatically
be hidden in wide layout.

Example:
```html
<cells-app-drawer>
  <paper-header-panel slot="drawer">
    <paper-toolbar>
      <div>Application</div>
    </paper-toolbar>
    <div> Drawer content... </div>
  </paper-header-panel>
  <paper-header-panel slot="main">
    <paper-toolbar>
      <paper-icon-button icon="menu" paper-drawer-toggle></paper-icon-button>
      <div>Title</div>
    </paper-toolbar>
    <div> Main content... </div>
  </paper-header-panel>
</cells-app-drawer>
```

To position the drawer to the right, add `right-drawer` attribute.

```html
<cells-app-drawer right-drawer>
  <div slot="drawer"> Drawer panel... </div>
  <div slot="main"> Main panel... </div>
</cells-app-drawer>
```

## Styling

The following custom properties are available for styling:

| Custom property | Description | Default |
| --- | --- | --- |
| `--cells-app-drawer-scrim-opacity` | Scrim opacity | 1 |
| `--cells-app-drawer-drawer-container` | Mixin applied to drawer container | {} |
| `--cells-app-drawer-left-drawer-container` | Mixin applied to container when it's in the left side | {} |
| `--cells-app-drawer-main-container` | Mixin applied to main container | {} |
| `--cells-app-drawer-right-drawer-container` | Mixin applied to container when it's in the right side | {} |
| `--cells-app-drawer-scrim` | Mixin applied to scrim | {} |

 * @customElement
 * @extends {LitElement}
 * @demo demo/index.html
 * @appliesMixin CellsResizableMixin
 */
class CellsAppDrawer extends CellsResizableMixin(LitElement) {
  static get is() {
    return 'cells-app-drawer';
  }

  static get properties() {
    return {
      /**
       * The panel to be selected when `cells-app-drawer` changes to narrow
       * layout.
       */
      defaultSelected: {
        type: String,
        attribute: 'default-selected'
      },
      /**
       * If true, swipe from the edge is disabled.
       */
      disableEdgeSwipe: {
        type: Boolean,
        attribute: 'disable-edge-swipe'
      },
      /**
       * If true, swipe to open/close the drawer is disabled.
       */
      disableSwipe: {
        type: Boolean,
        attribute: 'disable-swipe'
      },
      /**
       * Width of the drawer panel.
       */
      drawerWidth: {
        type: String,
        attribute: 'drawer-width'
      },
      /**
       * How many pixels on the side of the screen are sensitive to edge
       * swipes and peek.
       */
      edgeSwipeSensitivity: {
        type: Number,
        attribute: 'edge-swipe-sensitivity'
      },
      /**
       * If true, ignore `responsiveWidth` setting and force the narrow layout.
       */
      forceNarrow: {
        type: Boolean,
        attribute: 'force-narrow'
      },
      /**
       * Whether the browser has support for the transform CSS property.
       */
      hasTransform: {
        type: Boolean,
        attribute: 'has-transform'
      },
      /**
       * Whether the browser has support for the will-change CSS property.
       */
      hasWillChange: {
        type: Boolean,
        attribute: 'has-will-change'
      },

      /**
       * Enable the drawer to peek out from the edge.
       */
      peek: {
        type: Boolean,
        reflect: true
      },

      /**
       * Max-width when the panel changes to narrow layout.
       */
      responsiveWidth: {
        type: String,
        attribute: 'responsive-width'
      },
      /**
       * If true, position the drawer to the right.
       */
      rightDrawer: {
        type: Boolean,
        attribute: 'right-drawer'
      },
      /**
       * The panel that is being selected. `drawer` for the drawer panel and
       * `main` for the main panel.
       */
      selected: {
        type: String,
        reflect: true
      },

      scaleContent: {
        type: Boolean,
        attribute: 'scale-content',
        reflect: true
      },
      /**
       * The attribute on elements that should toggle the drawer on tap, also elements will
       * automatically be hidden in wide layout.
       */
      drawerToggleAttribute: {
        type: String,
        attribute: 'drawer-toggle-attribute'
      },
      /**
       * The CSS selector for the element that should receive focus when the drawer is open.
       * By default, when the drawer opens, it focuses the first tabbable element. That is,
       * the first element that can receive focus.
       *
       * To disable this behavior, you can set `drawerFocusSelector` to `null` or an empty string.
       *
       */
      drawerFocusSelector: {
        type: String,
        attribute: 'drawer-focus-selector'
      },

      _mediaQueryMatch: {
        type: Boolean
      }
    };
  }

  constructor() {
    super();
    this.defaultSelected = 'main';
    this.disableEdgeSwipe = false;
    this.disableSwipe = false;
    this.dragging = false;
    this.drawerWidth = '100%';
    this.edgeSwipeSensitivity = 40;
    this.forceNarrow = false;
    this.hasTransform = 'transform' in this.style;
    this.hasWillChange = 'willChange' in this.style;
    this.peek = false;
    this.peeking = false;
    this.responsiveWidth = '768px';
    this.rightDrawer = false;
    this.selected = null;
    this.scaleContent = false;
    this.drawerToggleAttribute = 'paper-drawer-toggle';
    this.drawerFocusSelector = 'a[href]:not([tabindex="-1"]),' +
      'area[href]:not([tabindex="-1"]),' +
      'input:not([disabled]):not([tabindex="-1"]),' +
      'select:not([disabled]):not([tabindex="-1"]),' +
      'textarea:not([disabled]):not([tabindex="-1"]),' +
      'button:not([disabled]):not([tabindex="-1"]),' +
      'iframe:not([tabindex="-1"]),' +
      '[tabindex]:not([tabindex="-1"]),' +
      '[contentEditable=true]:not([tabindex="-1"])';
    this._transition = false;
  }

  firstUpdated() {
    super.firstUpdated();
    this._drawer = this.shadowRoot.querySelector('#drawer');
    this._main = this.shadowRoot.querySelector('#main');
    this._drawerContent = this.shadowRoot.querySelector('#drawerContent');
  }

  updated(changedProps) {
    if (changedProps.has('selected')) {
      this._toggleFocusListener(this.selected);
      this.dispatchEvent(new CustomEvent('selected-changed', {
        detail: {
          value: this.selected
        }
      }));
    }
    if (changedProps.has('forceNarrow') || changedProps.has('defaultSelected')) {
      this._forceNarrowChanged();
    }
  }

  connectedCallback() {
    super.connectedCallback();
    Gestures.addListener(this, 'tap', e => this._onTap(e));
    Gestures.addListener(this, 'down', e => this._downHandler(e));
    Gestures.addListener(this, 'up', e => this._upHandler(e));
    Gestures.addListener(this, 'track', e => this._onTrack(e));
    this._transition = true;
  }

  get _mediaQuery() {
    return '(max-width: ' + this.responsiveWidth + ')';
  }

  get narrow() {
    return this.forceNarrow || this._mediaQueryMatch;
  }

  get _drawerStyle() {
    return 'width:' + this.drawerWidth + ';';
  }

  get _mainStyle() {
    let style = '';
    style += 'left:' + (this.narrow || this.rightDrawer ? '0' : this.drawerWidth) + ';';
    if (this.rightDrawer) {
      style += 'right:' + (this.narrow ? '' : this.drawerWidth) + ';';
    }
    return style;
  }

  get _cellsSelectorClass() {
    return {
      dragging: this.dragging,
      'narrow-layout': this.narrow,
      'right-drawer': this.rightDrawer,
      'left-drawer': !this.rightDrawer,
      transition: this._transition,
      peeking: this.peeking
    };
  }

  get _swipeAllowed() {
    return this.narrow && !this.disableSwipe;
  }

  get _isMainSelected() {
    return this.selected === 'main';
  }

  static get styles() {
    return [
      styles,
      getComponentSharedStyles('cells-app-drawer-shared-styles')
    ];
  }

  render() {
    return html`
      <cells-media-query
        id="mq"
        @query-matches-changed="${this._onQueryMatchesChanged}"
        query="${this._mediaQuery}">
      </cells-media-query>

      <cells-selector
        attr-for-selected="id"
        class="${classMap(this._cellsSelectorClass)}"
        activate-event=""
        selected="${this.selected}">

        <div id="main" style="${this._mainStyle}">
          <slot name="main"></slot>
          <slot name="footer"></slot>
          <div id="scrim" @click="closeDrawer"></div>
        </div>

        <div id="drawer" style="${this._drawerStyle}">
          <slot id="drawerContent" name="drawer"></slot>
        </div>

      </cells-selector>
    `;
  }

  /**
   * Fired when the narrow layout changes.
   *
   * @event cells-app-responsive-change {{narrow: boolean}} detail -
   *     narrow: true if the panel is in narrow layout.
   */
  _responsiveChange() {
    this._setNarrow();
    this.selected = this.narrow ? this.defaultSelected : null;
    Gestures.setTouchAction(this, this._swipeAllowed ? 'pan-y' : 'auto');
    this.dispatchEvent(new CustomEvent('cells-app-responsive-change', {
      detail: {
        narrow: this.narrow
      },
      bubbles: true,
      composed: true
    }));
    this.requestUpdate();
  }

  _setNarrow() {
    if (this.narrow) {
      this.setAttribute('narrow', '');
    } else {
      this.removeAttribute('narrow');
    }
    /**
     * Fired when the panel is in narrow layout.  This is useful if you
     * need to show/hide elements based on the layout.
     * @event narrow-changed
     */
    this.dispatchEvent(new CustomEvent('narrow-changed', {
      detail: {
        value: this.narrow
      }
    }));
  }

  _setPeeking(value) {
    this.peeking = value;
    /**
     * Fired whether the drawer is peeking out from the edge.
     * @event peeking-changed
     */
    this.dispatchEvent(new CustomEvent('peeking-changed', {
      detail: {
        value: this.peeking
      }
    }));
  }

  _setDragging(value) {
    this.dragging = value;
    /**
     * Fired when the panel is being dragged.
     * @event dragging-changed
     */
    this.dispatchEvent(new CustomEvent('dragging-changed', {
      detail: {
        value: this.dragging
      }
    }));
    this.requestUpdate();
  }

  _onQueryMatchesChanged(event) {
    this._mediaQueryMatch = event.detail.value;
    this._responsiveChange();
  }

  _forceNarrowChanged() {
    this._responsiveChange();
  }

  /**
   * Toggles the panel open and closed.
   */
  togglePanel() {
    if (this._isMainSelected) {
      this.openDrawer();
    } else {
      this.closeDrawer();
    }
  }

  /**
   * Opens the drawer.
   */
  openDrawer() {
    requestAnimationFrame(() => {
      this._drawer.classList.toggle('transition-drawer', true);
      this.selected = 'drawer';
    });
  }

  /**
   * Closes the drawer.
   */
  closeDrawer() {
    requestAnimationFrame(() => {
      this._drawer.classList.toggle('transition-drawer', true);
      this.selected = 'main';
    });
  }

  _onTrack(event) {
    if (!(event && event.detail && event.detail.state)) {
      return;
    }

    if (sharedPanel && this !== sharedPanel) {
      return;
    }
    switch (event.detail.state) {
      case 'start':
        this._trackStart(event);
        break;
      case 'track':
        this._trackX(event);
        break;
      case 'end':
        this._trackEnd(event);
        break;
    }
  }

  _trackStart(event) {
    if (this._swipeAllowed) {
      /* eslint-disable consistent-this */
      sharedPanel = this;
      /* eslint-enable consistent-this */
      this._setDragging(true);
      if (this._isMainSelected) {
        this._setDragging(this.peeking || this._isEdgeTouch(event));
      }
      if (this.dragging) {
        this.width = this._drawer.offsetWidth;
        this._transition = false;
      }
    }
  }

  _isEdgeTouch(event) {
    var x = event.detail.x;
    return !this.disableEdgeSwipe && this._swipeAllowed && (this.rightDrawer ? x >= this.offsetWidth - this.edgeSwipeSensitivity : x <= this.edgeSwipeSensitivity);
  }

  _trackX(event) {
    if (this.dragging) {
      var dx = event.detail.dx;
      if (this.peeking) {
        if (Math.abs(dx) <= this.edgeSwipeSensitivity) {
          return;
        }
        this._setPeeking(false);
      }
      this._moveDrawer(this._translateXForDeltaX(dx));
    }
  }

  _trackEnd(event) {
    if (this.dragging) {
      var xDirection = event.detail.dx > 0;
      this._setDragging(false);
      this._transition = true;
      this.resetSharedPanel();
      this._moveDrawer(null);
      if (this.rightDrawer) {
        this[ xDirection ? 'closeDrawer' : 'openDrawer' ]();
      } else {
        this[ xDirection ? 'openDrawer' : 'closeDrawer' ]();
      }
    }
  }

  _moveDrawer(translateX) {
    const panel = this.scaleContent ? this._main : this._drawer;
    const transform = this._transformForTranslateX(translateX);
    panel.style.transform = transform;
  }

  _transformForTranslateX(translateX) {
    if (translateX === null) {
      return '';
    }
    if (this.scaleContent) {
      const left = this.rightDrawer ? Math.min(0, translateX * (95 / this.width) - 95) : Math.max(0, translateX * (95 / this.width) + 95);
      const scale = this.rightDrawer ? Math.min(1, translateX * ((1 - 0.66) / this.width) + 0.66) : Math.min(1, translateX * ((1 - 0.66) / -this.width) + 0.66);
      return this.hasWillChange ? 'scale(' + scale + ') translateX(' + left + 'vw)' : 'scale(' + scale + ') translate3d(' + left + 'vw, 0, 0)';
    }
    return this.hasWillChange ? 'translateX(' + translateX + 'px)' : 'translate3d(' + translateX + 'px, 0, 0)';
  }

  _startEdgePeek() {
    this.width = this._drawer.offsetWidth;
    this._moveDrawer(this._translateXForDeltaX(this.rightDrawer ? -this.edgeSwipeSensitivity : this.edgeSwipeSensitivity));
    this._setPeeking(true);
  }

  _stopEdgePeek() {
    if (this.peeking) {
      this._setPeeking(false);
      this._moveDrawer(null);
    }
  }

  _downHandler(event) {
    if (!this.dragging && this._isMainSelected && this._isEdgeTouch(event) && !sharedPanel && this.peek) {
      this._startEdgePeek();
      event.preventDefault();
      /* eslint-disable consistent-this */
      sharedPanel = this;
      /* eslint-enable consistent-this */
    }
  }

  _upHandler() {
    this._stopEdgePeek();
    this.resetSharedPanel();
  }

  resetSharedPanel() {
    sharedPanel = null;
  }

  _onTap(event) {
    var targetElement = event.target;
    var isTargetToggleElement = targetElement && this.drawerToggleAttribute && targetElement.hasAttribute(this.drawerToggleAttribute);
    if (isTargetToggleElement) {
      this.togglePanel();
    }
  }

  _translateXForDeltaX(deltaX) {
    var isMain = this._isMainSelected;
    if (this.rightDrawer) {
      return Math.max(0, isMain ? this.width + deltaX : deltaX);
    } else {
      return Math.min(0, isMain ? deltaX - this.width : deltaX);
    }
  }

  _getDrawerContent() {
    return this._drawerContent
      .assignedNodes({
        flatten: true
      })
      .filter(n => n.nodeType === Node.ELEMENT_NODE)[ 0 ];
  }

  _getAutoFocusedNode() {
    var drawerContent = this._getDrawerContent();
    return this.drawerFocusSelector ? drawerContent.querySelector(this.drawerFocusSelector) || drawerContent : null;
  }

  _toggleFocusListener(selected) {
    if (selected === 'drawer') {
      this.addEventListener('focus', this._didFocus, true);
    } else {
      this.removeEventListener('focus', this._didFocus, true);
    }
  }

  _didFocus(event) {
    var autoFocusedNode = this._getAutoFocusedNode();
    if (!autoFocusedNode) {
      return;
    }
    var path = event.composedPath();
    var focusedChild = path[ 0 ];
    var drawerContent = this._getDrawerContent();
    var focusedChildCameFromDrawer = path.indexOf(drawerContent) !== -1;
    if (!focusedChildCameFromDrawer) {
      event.stopPropagation();
      autoFocusedNode.focus();
    }
  }

  /**
   * Fired when the a panel is selected.
   *
   * Listening for this event is an alternative to observing changes in the `selected` attribute.
   * This event is fired both when a panel is selected.
   *
   * @event cells-select {{item: Object}} detail -
   *     item: The panel that the event refers to.
   */

  /**
   * Fired when a panel is deselected.
   *
   * Listening for this event is an alternative to observing changes in the `selected` attribute.
   * This event is fired both when a panel is deselected.
   *
   * @event cells-deselect {{item: Object}} detail -
   *     item: The panel that the event refers to.
   */
}
window.customElements.define(CellsAppDrawer.is, CellsAppDrawer);
