<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>cells-page test</title>
  <script src="../node_modules/@webcomponents/webcomponentsjs/webcomponents-loader.js"></script>
  <script src="../node_modules/mocha/mocha.js"></script>
  <script src="../node_modules/wct-mocha/wct-mocha.js"></script>
  <script src="../node_modules/chai/chai.js"></script>
  <script src="../node_modules/sinon/pkg/sinon.js"></script>
  <script src="../node_modules/@polymer/test-fixture/test-fixture.js"></script>
  <script src="../node_modules/sinon-chai/lib/sinon-chai.js"></script>
</head>

<body>

  <test-fixture id="default">
    <template>
      <cells-page></cells-page>
    </template>
  </test-fixture>

  <script type="module">
  import './test.js';
    suite('cells-page', () => {

      let el;
      let elementShadowRoot;

      setup(async () => {
        el = fixture('default');
        elementShadowRoot = el.shadowRoot;
        return await el.updateComplete;
      });

      test('it should handle connections', async () => {
          const handleConnectionsSpy = sinon.spy(el, '__handleConnections');
          await el.connectedCallback();
          expect(handleConnectionsSpy).calledOnce;
        });

        test('it should check for page handlers', async () => {
          const hasPageHandlersSpy = sinon.spy(el, '__hasPageHandlers');
          await el.connectedCallback();
          expect(hasPageHandlersSpy).to.have.been.called;
        });

        [
          { onPageEnter: () => {} },
          { onPageLeave: () => {} },
          { onPageEnter: () => {}, onPageLeave: () => {} }
        ].forEach(config => {
          test('it should handle defined page hooks', () => {
            const handlePagePrivateChannelSpy = sinon.spy(el, '__handlePagePrivateChannel');

            Object.assign(el, config);
            el.connectedCallback();
            expect(handlePagePrivateChannelSpy).to.have.been.called;
          });
        });

        [
          { onEnter: () => {}, onLeave: () => {} },
        ].forEach(config => {
          test('it should not handle fake page hooks', () => {
            const handlePagePrivateChannelSpy = sinon.spy(el, '__handlePagePrivateChannel');

            Object.assign(el, config);
            el.connectedCallback();
            expect(handlePagePrivateChannelSpy).to.not.have.been.called;
          });
        });

        [
          { value: true, expectedPrivateChannelCallback: 'onPageEnter' },
          { value: false, expectedPrivateChannelCallback: 'onPageLeave' }
        ].forEach(config => {
          test('it should create private channel callback and execute it based on page status', () => {
            const { value, expectedPrivateChannelCallback } = config;
            const callbackSpy = sinon.spy();

            el[expectedPrivateChannelCallback] = callbackSpy;

            const privateChannelCallback = el.__wrapPrivateChannelCallback();

            privateChannelCallback({ value });

            expect(callbackSpy).to.have.been.called;
          });
        });

    });
  </script>

</body>

</html>
